<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/27/KEGG-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/27/KEGG-API/" class="post-title-link" itemprop="url">KEGG_API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-27 22:32:31" itemprop="dateCreated datePublished" datetime="2024-10-27T22:32:31+08:00">2024-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-28 15:40:48" itemprop="dateModified" datetime="2024-10-28T15:40:48+08:00">2024-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用KEGG-API获取代谢通路数据"><a href="#使用KEGG-API获取代谢通路数据" class="headerlink" title="使用KEGG API获取代谢通路数据"></a>使用KEGG API获取代谢通路数据</h1><p><a target="_blank" rel="noopener" href="https://www.kegg.jp/">KEGG数据库</a>中包含了大量与细胞代谢，分子层级调控相关的数据信息，是做通路分析的重要且权威的数据库网站。</p>
<p>在科研实践的过程中，我们关注于某一特定的代谢通路，例如光合作用。那么自然而然地，我们想要知道，有哪些基因，哪些代谢物参与到光合作用过程中。那么我们就可以在KEGG官方站点中搜索”photosynthesis”，找到对应的Pathway编号(map开头)，获取光合作用这条通路的大致信息。<br><img src="/./img/KEGG_API/map00195.png" alt="KEGG中map页面示例(map00195)"><br>更进一步，我们想要去了解这条通路中包含的各个代谢物与基因，则我们要去找到他对应的KO pathway编号(ko开头)，就可以在新的页面中获取该通路涉及的基因与代谢物等。<br><img src="/./img/KEGG_API/map00195_ko.png" alt="KEGG中map页面中寻找ko编号(map00195)">  </p>
<p>但是通路涉及的基因与代谢物数量往往很多，很难再一个个手动操作去获取其对应信息。于是在这个时候，我们就需要通过调用<a target="_blank" rel="noopener" href="https://www.kegg.jp/kegg/rest/">KEGG的API</a>(个人数据库提供一个网络接口让用户可以更加快捷的访问数据库内的数据)去批量获取代谢通路数据了。<br><img src="/./img/KEGG_API/ko00195.png" alt="KEGG中ko页面示例(map00195)"></p>
<p>tips: KEGG中的编号前缀均有其意义，例如 前缀C代表Compound，表明<code>CXXXX</code> 该ID对应的为一个化合物……可以参考<a target="_blank" rel="noopener" href="https://www.kegg.jp/kegg/rest/keggapi.html">官方文档</a>或其他<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d7656c2e2cbe">介绍KEGG数据库的文档</a></p>
<h2 id="明确调用API需求"><a href="#明确调用API需求" class="headerlink" title="明确调用API需求"></a>明确调用API需求</h2><p>我主要想去获取参与到 光合作用 代谢通路上的所有基因的名称(Name)与简写(Symbol)，而每一个基因（准确来说是KEGG ORTHOLOGY,KO）在KEGG上的介绍页面路径为: <a target="_blank" rel="noopener" href="https://www.kegg.jp/entry/K0XXXX">https://www.kegg.jp/entry/K0XXXX</a> , 数据排列情况如下所示。<br><img src="/./img/KEGG_API/K02718.png" alt="KEGG中K编号页面示例(K02718)"></p>
<p>所以，只需要：<br>①获取KO编号<br>②构建出访问KEGG数据库中该基因编号的信息路径<br>③然后使用requests工具，获取对应路径所包含的信息<br>④提取信息中的Symbol与Name<br>随后，就可以完成基因信息的提取。</p>
<p>tips:关于html文档的解析与html元素的解析可能会在后续的文档中介绍。</p>
<h2 id="调用API脚本"><a href="#调用API脚本" class="headerlink" title="调用API脚本"></a>调用API脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_labels_in_kegg_entry_html</span>(<span class="params">tmp_soup, key:<span class="built_in">str</span></span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    从KEGG数据库条目的HTML内容中提取特定键（key）对应的标签（label）值。  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    参数:  </span></span><br><span class="line"><span class="string">    tmp_soup (BeautifulSoup对象): 包含KEGG数据库条目HTML内容的BeautifulSoup对象。  </span></span><br><span class="line"><span class="string">    key (str): 要查找的标签名称的字符串。  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    返回:  </span></span><br><span class="line"><span class="string">    str: 如果找到对应的标签，则返回其文本内容（去除前后空白）。  </span></span><br><span class="line"><span class="string">    None: 如果没有找到对应的标签，则返回None并打印一条消息。  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">    <span class="comment"># 在HTML内容中查找包含指定键的&lt;th&gt;标签。 由于KEGG页面中主要是这个标签，可以根据具体API所需调用高的内容更换标签  </span></span><br><span class="line">    <span class="comment"># 使用lambda函数来检查&lt;th&gt;标签的文本内容是否包含指定的键。  </span></span><br><span class="line">    tmp_th = tmp_soup.find(<span class="string">&#x27;th&#x27;</span>, string=<span class="keyword">lambda</span> a: <span class="built_in">isinstance</span>(a, <span class="built_in">str</span>) <span class="keyword">and</span> key <span class="keyword">in</span> a)  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 如果找到了对应的&lt;th&gt;标签  </span></span><br><span class="line">    <span class="keyword">if</span> tmp_th:  </span><br><span class="line">        <span class="comment"># 找到&lt;th&gt;标签的下一个同级&lt;td&gt;标签，它通常包含标签的值。  </span></span><br><span class="line">        tmp_td = tmp_th.find_next_sibling(<span class="string">&#x27;td&#x27;</span>)  </span><br><span class="line">        <span class="comment"># 返回&lt;td&gt;标签中的文本内容，并去除前后的空白字符。  </span></span><br><span class="line">        <span class="keyword">return</span> tmp_td.get_text().strip()  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="comment"># 如果没有找到对应的&lt;th&gt;标签，打印一条消息说明未找到。  </span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Not Found <span class="subst">&#123;key&#125;</span> in the query soup&#x27;</span>)  </span><br><span class="line">        <span class="comment"># 返回None表示未找到对应的标签值。  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API前缀</span></span><br><span class="line">prefix_url=<span class="string">&quot;https://www.kegg.jp/entry/&quot;</span></span><br><span class="line">querys = [ <span class="string">&quot;K00001&quot;</span> , ... ]     <span class="comment"># 需要查询的基因的K编号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tmp_k_ID <span class="keyword">in</span> querys:</span><br><span class="line">    <span class="comment"># 预处理K编号，避免空格等字符输入</span></span><br><span class="line">    tmp_k_ID = tmp_k_ID.strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用requests.get方法获取对应K编号基因的KEGG API内容</span></span><br><span class="line">    tmp_response = requests.get( prefix_url+tmp_k_ID )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将网页文本内容解析为soup对象</span></span><br><span class="line">    tmp_sp = BeautifulSoup( tmp_response.text , <span class="string">&quot;html.parser&quot;</span> )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取Symbol标签和Name标签后的数据信息</span></span><br><span class="line">    tmp_sym, tmp_name = get_labels_in_kegg_entry_html( tmp_sp , <span class="string">&#x27;Symbol&#x27;</span>) , get_labels_in_kegg_entry_html( tmp_sp , <span class="string">&#x27;Name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出该K编号的基因信息结果</span></span><br><span class="line">    <span class="built_in">print</span>( tmp_k_ID+<span class="string">&#x27;*&#x27;</span>+ tmp_sym +<span class="string">&#x27;*&#x27;</span>+ tmp_name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体BeatifulSoup的使用方法可以参考其<a target="_blank" rel="noopener" href="https://beautifulsoup.cn/">官方文档</a>，后续我个人应当也会更新相应的用法与我自身对这个包的理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/22/fastp-Usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/fastp-Usage/" class="post-title-link" itemprop="url">fastp Usage</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 20:16:53" itemprop="dateCreated datePublished" datetime="2024-10-22T20:16:53+08:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-24 23:09:36" itemprop="dateModified" datetime="2024-10-24T23:09:36+08:00">2024-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Fastp使用方法与原理详解"><a href="#Fastp使用方法与原理详解" class="headerlink" title="Fastp使用方法与原理详解"></a>Fastp使用方法与原理详解</h1><p>平时在收到公司返回的原始数据后，我通常使用Fastp来进行数据的质量控制与预处理，一方面是因为使用的命令行比较方便，另一方面也是因为他的速度快于其他的质控&#x2F;预处理软件。在之前的工作流程中，我也介绍了这个软件在命令行的简单使用方法。总觉得对测序数据预处理的原理与方法了解的不够深入。</p>
<p>因此，我想要通过这篇博客再深入了解数据预处理的相关知识与Fastp命令各个参数的详解。</p>
<h2 id="测序数据"><a href="#测序数据" class="headerlink" title="测序数据"></a>测序数据</h2><p>无论是任何测序数据类型（一代，二代，三代等），它主要可以由两个信息去描述:一个是 <strong>序列信息</strong> ,另一个就是每个测序位点的 __质量信息__。<br>以二代测序为例，我们通常得到的测序结果的文件格式为 <strong>fastq</strong> 格式，每一条测序信息由四行内容组成：①ID，②序列信息，③附加(一般都是空的)，④质量信息(phred)</p>
<blockquote>
<p>@E200028359L1C001R00300000544&#x2F;2<br>ACACATAAAATCTTTGGACCCTTTAAG<br>+<br>FGGGGFFGGFGFGGGFGFGFGG&lt;GEGF</p>
</blockquote>
<p>如上的四行就表明了一条测序信息：该条序列的ID为<code>E200028359L1C001R00300000544</code>(由于是双端测序，所以ID后面还带了一个<code>/2</code>，表明其为 read2 )；测序仪测得该条序列的碱基顺序为<code>ACACATAAAATCTTTGGACCCTTTAAG</code>；每个碱基的对应的测序质量为<code>FGGGGFFGGFGFGGGFGFGFGG&lt;GEGF</code>。</p>
<p>值得注意的是，不同的公司可能会用不同的质量编码标准，可以参考<a target="_blank" rel="noopener" href="https://blog.sciencenet.cn/blog-630246-813262.html">这一篇文章</a>或<a target="_blank" rel="noopener" href="https://www.phrap.com/phred/">phred官方说明</a>。</p>
<h2 id="质量控制（Quality-Control，QC）"><a href="#质量控制（Quality-Control，QC）" class="headerlink" title="质量控制（Quality Control，QC）"></a>质量控制（Quality Control，QC）</h2><p>那么基于测序信息所提供的两种信息（序列，质量），我们该如何对测序数据进行质量控制？</p>
<p><strong>序列信息</strong></p>
<ul>
<li>序列重复度</li>
<li>序列各位置的碱基分布（个人认为与二代测序原理相关）</li>
<li>k-mer偏好</li>
<li>接头污染</li>
<li>碱基平衡，ATCG的总比例应该与测序样本原始比例相当</li>
<li>未知碱基数量，有些位点测出来的碱基可能为N</li>
</ul>
<p><strong>质量信息</strong></p>
<ul>
<li>每条序列的测序质量</li>
<li>序列个位置的测序质量（个人认为与二代测序原理相关）</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>序列长度分布</li>
<li>PE数据的插入片段大小，我们可以根据双端数据在首尾之间的重叠区域判断原始片段的长度</li>
</ul>
<p>不同的质量控制软件有不同的指标去评估每一条数据的测序质量，在<code>fastp</code>中还用了序列的复杂度作为评估指标。质量控制一方面可以让我们了解测序数据整体上是否存在一些问题，另一方面可以过滤异常的低质量reads，目的是令最终的reads都是质量合格的reads。</p>
<h2 id="预处理（Preprocessing）"><a href="#预处理（Preprocessing）" class="headerlink" title="预处理（Preprocessing）"></a>预处理（Preprocessing）</h2><p>严格来说，上述的 <strong>质量控制</strong> 也属于数据预处理的一部分。但我们从上面的内容可以看到，传统的质量控制步骤主要是对 <strong>整条reads</strong> 去进行操作的，比如过滤掉整条低质量reads。</p>
<p>但是在实际操作过程中，我们会发现所有的reads会存在一些普遍问题，例如：</p>
<p><strong>序列信息</strong></p>
<ul>
<li>片段被完全测通，接头序列污染了文库</li>
<li>测序文库特有结构，特定区域碱基不平衡</li>
</ul>
<p><strong>质量信息</strong></p>
<ul>
<li>开头的测序质量比较差，后面序列的碱基质量稳定</li>
</ul>
<p>采取原来整条过滤的方法，会过滤掉其中包含了大量有效信息的内容。<br>这些问题或需求的存在使得我们需要对测序结果进行 <strong>局部处理（裁剪）</strong> ：裁剪掉低质量序列，裁剪掉接头序列，裁剪掉特有文库，使之能够符合后续比对或进行其他操作的要求。</p>
<p>综上所述，我们主要通过测序数据的序列信息和质量信息，对测序数据进行裁剪与质量控制等操作，最终得到的每条序列都是有价值且质量合格的。</p>
<h2 id="Fastp使用方法"><a href="#Fastp使用方法" class="headerlink" title="Fastp使用方法"></a>Fastp使用方法</h2><p>那么按照上述逻辑，我们需要进行：质量控制(FastQC)→裁剪(Trimmomatic)→质量控制(FastQC)的方式完成数据的预处理。<br><code>Fastp</code>将上述过程进行整合，并采用并行计算的方法加速了数据预处理过程。</p>
<hr>
<p>参考资料<br>[1] <a target="_blank" rel="noopener" href="https://open.bioqueue.org/home/knowledge/showKnowledge/sig/fastp">Manual of fastp</a><br>[2] <a target="_blank" rel="noopener" href="https://onlinelibrary.wiley.com/doi/10.1002/imt2.107">Ultrafast one-pass FASTQ data preprocessing, quality control, and deduplication using fastp</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/10/Demension-Reduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/10/Demension-Reduction/" class="post-title-link" itemprop="url">Demension Reduction</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-10 15:09:05" itemprop="dateCreated datePublished" datetime="2024-10-10T15:09:05+08:00">2024-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-11 16:18:03" itemprop="dateModified" datetime="2024-10-11T16:18:03+08:00">2024-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>高维数据的处理难度大，耗时长，且不同维度之间的相关性或数据的稀疏性又会影响最后的分析结果。对高维数据进行降维能够有效提升数据的分析效率。<br>降维顾名思义就是降低数据的维度（Demension），比如将一个100维的向量转化为一个2维的向量，这就是降维。那么如何实现100D → 2D呢？</p>
<blockquote>
<p>以下文字并不专业，只是我个人的朴素理解，具体的降维概念与详细解释可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/ck784101777/article/details/107148133">数据降维之特征选择</a>或者直接咨询人工智能</p>
</blockquote>
<ol>
<li>维度筛选。我只选择第1，2维的数据作为每个样本点的数据表示，其他98维的数据我全部舍弃。</li>
<li>维度整合。例如我把前面50维和后50维的数据求和，所得的2个和即为每个样本点的数据表示。<br>……</li>
</ol>
<p>当然，看了前面我举的两个例子，你可能会觉得这好像可行，但这听上去并不科学啊！为什么选择这些维度或维度组合作为特征呢？为什么是相加而不是相乘呢？</p>
<p>所以，大家常用的降维方法并不是上文提的那种朴素降维方法（但部分情况下也可以考虑上述降维方法）。笔者知道常用的降维方法有<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37777074">PCA(线性降维方法)</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/scott198510/article/details/76099700">t-SNE(非线性降维方法)</a>，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/704060deaa3f">UMAP(非线性降维方法)</a>，其数学原理与科学性并不在本文中展开了，在本文中主要分享这些 __降维方法在python中如何使用sklearn等工具包实现__。</p>
<h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>在我分析的过程中使用的数据为实验样本的相似矩阵（ 14471 × 14471 ），且分析环境为python，可以自行构建随机矩阵模拟测试数据。</p>
<p>加载实现降维分析所需要的python库。如果没有这些库的话，请先pip install。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> umap</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> manifold</span><br></pre></td></tr></table></figure>

<p>生成测试数据的随机矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_random_matrix</span>(<span class="params">N_sample: <span class="built_in">int</span>, M_dimension: <span class="built_in">int</span>, C_types: <span class="built_in">int</span></span>):  </span><br><span class="line">    <span class="comment"># 生成原始类型矩阵，整数类型  </span></span><br><span class="line">    original_types = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=[C_types, M_dimension])  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 预先分配结果矩阵  </span></span><br><span class="line">    matrix = np.zeros((N_sample, M_dimension))  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 生成每个数据的原始类别索引  </span></span><br><span class="line">    types = np.random.randint(<span class="number">0</span>, C_types, size=N_sample)  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 使用向量化操作填充矩阵  </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N_sample):  </span><br><span class="line">        selected_type = original_types[types[i]]  </span><br><span class="line">        matrix[i] = selected_type + np.random.rand(M_dimension)  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> matrix, types</span><br><span class="line">    </span><br><span class="line">test_data,test_types = generate_random_matrix(<span class="number">1000</span>,<span class="number">1000</span>,<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>以sklearn中的PCA模块进行测试学习，主要分为以下几个步骤：初始化PCA对象，PCA对象拟合测试数据，PCA对象对测试数据进行维度转化，可视化结果，后续处理（聚类等）。<br><a target="_blank" rel="noopener" href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html">sklearn.PCA 官方文档</a></p>
<h3 id="生成PCA对象"><a href="#生成PCA对象" class="headerlink" title="生成PCA对象"></a>生成PCA对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般只考虑n_components参数，</span></span><br><span class="line"><span class="comment"># 当n_componets参数为整数n时，该PCA会将数据降至n维；</span></span><br><span class="line"><span class="comment"># 当其为0-1的小数f%时，该PCA会将数据降至x维，</span></span><br><span class="line"><span class="comment"># 这x维是能够解释f%的数据变异程度的最小维度。</span></span><br><span class="line"></span><br><span class="line">test_pca = PCA(n_components=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># test_pca = PCA(n_components=0.99)</span></span><br></pre></td></tr></table></figure>

<h3 id="拟合测试数据与数据降维"><a href="#拟合测试数据与数据降维" class="headerlink" title="拟合测试数据与数据降维"></a>拟合测试数据与数据降维</h3><p>将数据输入至PCA对象中，提取出数据中的主要维度组成，通过调用<code>.explained_variance_ratio_</code>属性，可以看到每个主成分对数据变异程度的解释。随后我们就可以根据PCA对象中的主成分，将原始高维向量转化为低微向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PCA对象拟合数据</span></span><br><span class="line">test_pca.fit(test_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取原始高维数据的低维表示，或者也可以将其他同维度数据用这些主成分表示</span></span><br><span class="line">test_data_pca = test_pca.transform( test_data )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将两个过程整合在一起</span></span><br><span class="line">test_data_pca = test_pca.fit_transform( test_data )</span><br></pre></td></tr></table></figure>

<p>tips: 我们可以用以下脚本可视化每个维度对数据的解释程度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据图片我们可知我们的测试数据中的主要部分可以由3个主成分来表示。可以用来表示降维效果</span></span><br><span class="line">plt.plot( np.cumsum( test_pca.explained_variance_ratio_ ) )</span><br><span class="line">plt.xlabel(<span class="string">&#x27;PC&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;explained_variance&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PCA怎么提取主成分的可以从.components_属性中获取，其为n_compents*M维矩阵，每个M维向量表示了各个维度的加权。PCA对象中的其他方法与属性不常用，就不作展开了，感兴趣的可以自行去官网了解。</span></span><br><span class="line">test_pca.components_</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/./img/demension_reducer/PCA_variance.png" alt="test_pca各主成分维度对数据的变异程度解释"></p>
<h3 id="PCA结果可视化"><a href="#PCA结果可视化" class="headerlink" title="PCA结果可视化"></a>PCA结果可视化</h3><p>我们根据提取出来的主成分对每个样本点进行可视化，根据之前的数据变异程度我们可以知道，PCA前四维应该能够将不同数据间分离。而后面的维度无法对数据进行很好的区分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x,y = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">plt.scatter( test_data_pca[:,x] , test_data_pca[:,y] , c=test_types )</span><br><span class="line">plt.xlabel(<span class="string">&#x27;PC%d&#x27;</span>%(x))</span><br><span class="line">plt.ylabel(<span class="string">&#x27;PC%d&#x27;</span>%(y))</span><br><span class="line">plt.colorbar()</span><br></pre></td></tr></table></figure>
<p><img src="/./img/demension_reducer/PCA_sample_plot.png" alt="有效PCA降维结果表示"></p>
<p>不同类别样本在PC4维度上的分布无差异，表明PC4维度基本上不包含数据样本点类别的信息。使用原始数据的维度完全无法对数据进行分类（右下），表明PCA降维操作可以帮我们提取出高维数据中的有效信息。<br><img src="/./img/demension_reducer/PCA_plot.png" alt="降维后数据的可视化表示"></p>
<h2 id="UMAP"><a href="#UMAP" class="headerlink" title="UMAP"></a>UMAP</h2><p>UMAP采用的是一种非线性降维方法，基于黎曼流形什么的，具体可以参考<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1802.03426">UMAP原文</a>。在python中使用umap的软件包叫umap-learn，具体的使用流程与PCA相近：建立UMAP对象，数据拟合，维度转化，可视化。</p>
<p><a target="_blank" rel="noopener" href="https://umap-learn.readthedocs.io/en/latest/parameters.html">umap-learn官方文档</a>，官方文档写得比我详细得多，<strong>强烈建议</strong> 去学习一下！！！</p>
<h3 id="生成UMAP对象"><a href="#生成UMAP对象" class="headerlink" title="生成UMAP对象"></a>生成UMAP对象</h3><p>生成umap对象时所用的参数比PCA稍多一些，且不同的参数对最后的降维结果有着比较大的影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test_umap = umap.UMAP(</span><br><span class="line">        n_neighbors=n_neighbors,</span><br><span class="line">        min_dist=min_dist,</span><br><span class="line">        n_components=n_components,</span><br><span class="line">        metric=metric,</span><br><span class="line">        random_state=random_state</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># n_neighbors, 对每个点进行降维操作时考虑的临近点的数量，使这些临近点群之间的相似度更高。这个值得根据类群大小定义才好，太小的话没有办法考虑到同一类群其他点的信息，太大的话会把不同类群点的信息合在一起。</span></span><br><span class="line"><span class="comment"># min_dist，降维后数据点的最短距离，数值越小，类群内更加密集</span></span><br><span class="line"><span class="comment"># n_components, 降维后的维度，与PCA相近，但不可以用小数。值得注意的是，如果用不同的n_components得到的同一维度的数值可能不一样。</span></span><br><span class="line"><span class="comment"># metirc, 点对之间的距离计算方法，通常为欧氏距离&quot;euclidean&quot;</span></span><br><span class="line"><span class="comment"># random_state, 随机种子，稳定计算结果</span></span><br></pre></td></tr></table></figure>

<h3 id="拟合测试数据与数据降维-1"><a href="#拟合测试数据与数据降维-1" class="headerlink" title="拟合测试数据与数据降维"></a>拟合测试数据与数据降维</h3><p>这一步骤和PCA相同，两步可以分开，也可以合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UMAP对象拟合数据</span></span><br><span class="line">test_umap.fit(test_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取原始高维数据的低维表示，或者也可以将其他同维度数据用这些主成分表示</span></span><br><span class="line">test_data_umap = test_umap.transform( test_data )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将两个过程整合在一起</span></span><br><span class="line">test_data_umap = test_umap.fit_transform( test_data )</span><br></pre></td></tr></table></figure>
<p>UMAP对象中也包含了许多属性与方法，记录了UMAP计算过程中的一些中间参数与中间数据。</p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>基本上与PCA一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter( test_data_umap[:,0] , test_data_umap[:,1] , c=test_types )</span><br><span class="line">plt.xlabel(&#x27;UMAP%d&#x27;%(0))</span><br><span class="line">plt.ylabel(&#x27;UMAP%d&#x27;%(1))</span><br><span class="line">plt.title(&quot;UMAP_plot&quot;)</span><br><span class="line">plt.colorbar()</span><br></pre></td></tr></table></figure>
<p><img src="/./img/demension_reducer/UMAP_sample_plot.png" alt="UMAP测试绘图"></p>
<h3 id="UMAP对象不同参数设置的影响"><a href="#UMAP对象不同参数设置的影响" class="headerlink" title="UMAP对象不同参数设置的影响"></a>UMAP对象不同参数设置的影响</h3><p>因为数据集相对比较简单，n_neighbors值大对聚类结果影响不是很大，官网教程中大n_neighbors值会出现聚类弥散。<br><img src="/./img/demension_reducer/UMAP_n_neighbor_plot.png" alt="不同n_neighbors的UMAP降维图"></p>
<p>min_dist变大后可以使得类群点变得相对弥散<br><img src="/./img/demension_reducer/UMAP_min_dist_plot.png" alt="不同min_dist的UMAP降维图"></p>
<p>不同n_componets下，不同UMAP降维得到的同一维度值不一样<br><img src="/./img/demension_reducer/UMAP_n_components_plot.png" alt="不同n_componets的UMAP降维图"></p>
<p>相同random_state下，能复现出实验结果<br><img src="/./img/demension_reducer/UMAP_random_state_plot.png" alt="不同random_state的UMAP降维图"></p>
<h2 id="t-SNE"><a href="#t-SNE" class="headerlink" title="t-SNE"></a>t-SNE</h2><p>t-SNE的使用方法差异也主要在第一步构建模型。具体了解t-SNE算法与原理可以学习<a target="_blank" rel="noopener" href="https://distill.pub/2016/misread-tsne/">t-SNE可视化学习</a>，里面还包含了t-SNE原文，感兴趣的可以了解。</p>
<p>由于主要的过程都差不多，我这边就把所有代码都放在一起了，主要再解释一下构建t-SNE对象参数。<br><a target="_blank" rel="noopener" href="https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html">t-SNE官方文档</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test_tsne = manifold.TSNE(</span><br><span class="line">   n_components=<span class="number">2</span>,</span><br><span class="line">   init=<span class="string">&#x27;pca&#x27;</span>,</span><br><span class="line">   random_state=<span class="number">22</span> ,</span><br><span class="line">   perplexity=<span class="number">30</span> </span><br><span class="line">   )</span><br><span class="line"><span class="comment"># n_components, 降维的维度，但好像不能大于等于4，因为算法中的oct-tree结构</span></span><br><span class="line"><span class="comment"># init, 初始化的嵌入数值的方法，默认为&#x27;pca&#x27;，还可以选择&#x27;random&#x27;</span></span><br><span class="line"><span class="comment"># random_state, 与UMAP中的参数一致</span></span><br><span class="line"><span class="comment"># perplexity, 与UMAP中的n_neighbors相近，为降维过程中的考虑点数</span></span><br><span class="line"><span class="comment"># n_iter, 迭代次数</span></span><br><span class="line"><span class="comment"># max_iter, 最大迭代次数</span></span><br><span class="line"><span class="comment"># metric, 距离计算方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_data_tsne = test_tsne.fit_transform(test_data)</span><br><span class="line"></span><br><span class="line">plt.scatter( test_data_tsne[:,<span class="number">0</span>] , test_data_tsne[:,<span class="number">1</span>] , c=test_types )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/./img/demension_reducer/t-SNE_plot.png" alt="t-SNE样本数据可视化"></p>
<h2 id="个人小结"><a href="#个人小结" class="headerlink" title="个人小结"></a>个人小结</h2><p>这些降维方法在python上的实现与应用并不困难。对于大部分有数据，使用方法默认的参数就可以得到一些比较不错的降维结果，但也记得用多种方法交叉验证下降维结果是否可靠。</p>
<p>但在部分情况下，面对一些不曾接触过的数据类型，如何根据 <strong>数据本身的特征</strong> ，选择合适的降维方法与调整降维参数是一个值得去思考的事。</p>
<p>然后遇到降维结果与预期存在差异，可能也需要从 <strong>降维方法原理</strong> 出发，去推断到底是方法选的不对，还是数据本身存在问题</p>
<p><strong>官方文档</strong> 真的很详细，很重要。看人博客，实验记录也就图一乐，解决不了的问题，不明白的参数，请去参阅官方文档。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/26/ChIP-without-control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/26/ChIP-without-control/" class="post-title-link" itemprop="url">ChIP_without_control</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-26 14:52:00" itemprop="dateCreated datePublished" datetime="2024-09-26T14:52:00+08:00">2024-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-27 21:37:59" itemprop="dateModified" datetime="2024-09-27T21:37:59+08:00">2024-09-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pipeline-of-analysing-ChIP-seq-datas-without-control"><a href="#Pipeline-of-analysing-ChIP-seq-datas-without-control" class="headerlink" title="Pipeline of analysing ChIP-seq datas without control"></a>Pipeline of analysing ChIP-seq datas without control</h1><blockquote>
<p>在ChIP实验时，忘记设计了control空白对照，使得再后续MACS3 call peaks的时候无法使用 <code>-c</code>，会使最后的结果可能存在较多的假阳性，但也可以继续分析。</p>
</blockquote>
<h2 id="01-变量声明与数据预处理"><a href="#01-变量声明与数据预处理" class="headerlink" title="01.变量声明与数据预处理"></a>01.变量声明与数据预处理</h2><p>1.1 变量声明</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sampleID    # 样本名称，测序结果文件前缀</span><br><span class="line">genome_idx  # 存储样本基因组的比对（BWA或 bowtie2等）索引</span><br><span class="line">genome_size # 基因组大小</span><br><span class="line">genome_gene_bed # 基因组基因位置注释文件，BED6格式</span><br><span class="line">data_path   # 存储测序结果的路径</span><br><span class="line">out_path    # 输出结果文件的路径</span><br><span class="line"></span><br><span class="line">sam_map_q=10    # 过滤比对结果的MAPQ阈值</span><br><span class="line">sam_sort_threads=20 # 使用samtools进行排序时使用的核数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.2 数据预处理<br>使用<a target="_blank" rel="noopener" href="https://github.com/OpenGene/fastp">fastp</a>对原始测序数据进行质量控制，主要去除一些低质量碱基与接头。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fastp --in1 $&#123;data_path&#125;/$&#123;sampleID&#125;_1.fq.gz --in2 $&#123;data_path&#125;/$&#123;sampleID&#125;_2.fq.gz \</span><br><span class="line">    --out1 $&#123;out_path&#125;/$&#123;sampleID&#125;_clean_R1.fq.gz --out2 $&#123;out_path&#125;/$&#123;sampleID&#125;_clean_R2.fq.gz \</span><br><span class="line">    --json $&#123;out_path&#125;/$&#123;sampleID&#125;.json --html $&#123;out_path&#125;/$&#123;sampleID&#125;.html \</span><br><span class="line">    --trim_poly_g --poly_g_min_len 10 \</span><br><span class="line">    --trim_poly_x --poly_x_min_len 10 \</span><br><span class="line">    --cut_front --cut_tail \</span><br><span class="line">    --cut_window_size 4 \</span><br><span class="line">    --qualified_quality_phred 30 \</span><br><span class="line">    --low_complexity_filter --complexity_threshold 30 \</span><br><span class="line">    --length_required 30 \</span><br><span class="line">    --thread 10 &gt; $&#123;out_path&#125;/$&#123;sampleID&#125;_fastp.log</span><br></pre></td></tr></table></figure>

<h2 id="02-基因组比对"><a href="#02-基因组比对" class="headerlink" title="02.基因组比对"></a>02.基因组比对</h2><p>使用BWA-MEM2, bowtie2 或其他基因组比对文件，将fastp处理后的clean data比对到参考基因组上，初步获取ChIP-seq比对结果。若在原始数据中存在 SPIKE IN 序列，则需要再将测序文件与 SPIKE IN的比对索引基因比对，数据的处理方式与下述相同，处理过程中使用 <code>$&#123;sampleID&#125;_spikein</code> 指代。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在本次实验中主要使用了BWA-MEM2进行比对</span></span><br><span class="line">bwa-mem2 mem -t 20 \</span><br><span class="line">    $&#123;genome_idx&#125;  \</span><br><span class="line">    $&#123;data_path&#125;/$&#123;sampleID&#125;_clean_R1.fq.gz $&#123;data_path&#125;/$&#123;sampleID&#125;_clean_R2.fq.gz \</span><br><span class="line">    -o $&#123;out_path&#125;/$&#123;sampleID&#125;.sam &amp;</span><br></pre></td></tr></table></figure>

<p>使用samtools对比对结果进行统计，过滤结果中的低质量比对，并对比对文件进行排序便于后续分析</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools view -Sb -F 0x04 -q $&#123;sam_map_q&#125; $&#123;out_path&#125;/$&#123;sampleID&#125;.sam &gt; $&#123;out_path&#125;/$&#123;sampleID&#125;.bam</span><br><span class="line">samtools sort --threads $&#123;sam_sort_threads&#125; $&#123;out_path&#125;/$&#123;sampleID&#125;.bam -o $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;.bam</span><br></pre></td></tr></table></figure>

<p>统计插入片段的大小分布并可视化（本次实验中使用自己编写的脚本，也可以使用Deeptools中的软件），简单评估实验数据的可靠性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">samtools view -F 0x04 $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;.bam | \</span><br><span class="line">    awk -F &#x27;\t&#x27; &#x27;function abs(x)&#123;return ((x &lt; 0.0) ? -x : x)&#125; &#123;print $1&quot;\t&quot;abs($9)&#125;&#x27;| \</span><br><span class="line">    sort | uniq  | cut -f 2 | sort | uniq -c  | \</span><br><span class="line">    awk -v OFS=&quot;\t&quot; &#x27;&#123;print $2, $1&#125;&#x27; &gt; $&#123;out_path&#125;/$&#123;sampleID&#125;_fragmentLen.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fragmentLen.txt结果文件包含两列，第一列为片段的长度，第二列为该长度片段在本次实验中的总数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己编写脚本可视化片段大小分布，第一个参数为样本名称，第二个参数为片段最长长度</span></span><br><span class="line">plot_frg.py $&#123;out_path&#125;/$&#123;sampleID&#125; 1000   </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt_frg.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_frag_file</span>(<span class="params"> file_path:<span class="built_in">str</span> </span>):</span><br><span class="line">    cnt_dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>( file= file_path ) <span class="keyword">as</span> f:</span><br><span class="line">        datas = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> tmp_line  <span class="keyword">in</span>  datas:</span><br><span class="line">            size, tmp_cnt = <span class="built_in">map</span>(<span class="built_in">int</span>, tmp_line.strip().split(<span class="string">&#x27;\t&#x27;</span>) )</span><br><span class="line">            cnt_dic[size] = tmp_cnt</span><br><span class="line">    <span class="keyword">return</span> cnt_dic</span><br><span class="line"></span><br><span class="line">sample=sys.argv[<span class="number">1</span>]</span><br><span class="line">frag_file= sample + <span class="string">&#x27;_fragmentLen.txt&#x27;</span></span><br><span class="line">limit = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">cnt_dic = read_frag_file( frag_file )</span><br><span class="line">plt.plot( [ i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(limit) ] , [cnt_dic.get(i,<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(limit)])</span><br><span class="line">plt.title(<span class="string">&#x27;%s Fragment Size Distribution&#x27;</span>%(sample))</span><br><span class="line"></span><br><span class="line">plt.savefig( <span class="string">&quot;%s_frag.svg&quot;</span>%(sample) )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/./img/ChIP/9-FLAG-CHIP_frag.svg" alt="9-ChIP的插入片段大小分布"></p>
<h2 id="03-Call-Peak"><a href="#03-Call-Peak" class="headerlink" title="03. Call Peak"></a>03. Call Peak</h2><p>要根据比对结果，统计不同基因组区间上的覆盖度来判断实验蛋白的潜在结合区域：在某一基因组区间内的reads数量越多，表明该区间越有可能被实验蛋白捕获，更有可能是潜在的结合位点。<br>通常使用 <strong>MACS3</strong> 来进行ChIP-seq数据的Peak calling，在类似的<a target="_blank" rel="noopener" href="https://yezhengstat.github.io/CUTTag_tutorial/#VI_Peak_calling">CUTTag数据分析流程</a>中中作者推荐使用SEACR。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">macs3 callpeak -t $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;.bam  -f BAMPE -n $&#123;out_path&#125;/$&#123;sampleID&#125; -g $&#123;genome_size&#125; -B -q 0.01 --keep-dup all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t, treat 给定实验组的比对结果文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c, control 给定对照组的比对结果文件，便于筛选真阳性的peak</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f, format 表示比对文件的格式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n, 输出结果的前缀</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g, 参考基因组大小</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--keep-dup, 表示对处理重复的方法，ChIP-<span class="built_in">seq</span>一般不进行PCR去重</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-B, 存储统计基因组区域所有reads pileup的bdg文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-q, Q值的阈值</span></span><br></pre></td></tr></table></figure>
<p>使用macs3 callpeak之后，会得到<code>$&#123;sampleID&#125;_peaks.xls</code> <code>$&#123;sampleID&#125;_peaks.narrowPeak</code> <code>$&#123;sampleID&#125;_summits.bed</code>等文件，分别记录了每个peak的宽度，在基因组上的位置，样本数据的覆盖信号值，置信度，peak中心区域，peak峰值点信息等。<br><br></p>
<p>（可选）从bam文件中提取分布在peaks内的比对结果，可以看到peaks在基因组上的分布情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bedtools intersect -a  $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;.bam  -b $&#123;out_path&#125;/$&#123;sampleID&#125;_peaks.narrowPeak  &gt; $&#123;out_path&#125;/$&#123;sampleID&#125;_peaks.bam</span><br></pre></td></tr></table></figure>

<p>（可选）提取top0.01的Peaks 尽可能减少假阳性结果对分析结果的影响</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=$( wc -l $&#123;out_path&#125;/$&#123;sampleID&#125;_peaks.narrowPeak | cut -d &#x27; &#x27; -f 1 ) ; </span><br><span class="line">sort -k 5nr $&#123;out_path&#125;/$&#123;sampleID&#125;_peaks.narrowPeak | head -$(( $&#123;a&#125; / 100 )) | sort -k 1n -k 2n &gt; $&#123;out_path&#125;/$&#123;sampleID&#125;_top0.01_peaks.bed</span><br></pre></td></tr></table></figure>

<p>（可选）多个样本间进行peaks的比较，分析差异peak，共有peak等， 这个可能需要spike-in的数据标准化会更准确。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待做 DiffBind、 DESeq2 、 bedtools</span><br></pre></td></tr></table></figure>


<p>（可选）使用IDR计算两个样本peaks之间的相关性，通常用于检查重复样本之间的重合率。该软件要求在计算之前，先按照peak的置信度对各个peak进行排序操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># narrowPeak BED文件按照pval排序</span><br><span class="line">sort -k8,8nr $&#123;sampleID&#125;_peaks.narrowPeak &gt; sorted_$&#123;sampleID&#125;_peaks.narrowPeak</span><br><span class="line"></span><br><span class="line">idr --samples sorted_$&#123;sampleID1&#125;.narrowPeak sorted_$&#123;sampleID2&#125;.narrowPeak \</span><br><span class="line">    --input-file-type narrowPeak \</span><br><span class="line">    --rank signal.value \</span><br><span class="line">    --output-file $&#123;sampleID1&#125;_$&#123;sampleID2&#125; \</span><br><span class="line">    --plot \</span><br><span class="line">    --log-output-file $&#123;sampleID1&#125;_$&#123;sampleID2&#125;.idr.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一步可以生成<code>$&#123;sampleID1&#125;_$&#123;sampleID2&#125;</code> <code>$&#123;sampleID1&#125;_$&#123;sampleID2&#125;.png</code> <code>$&#123;sampleID1&#125;_$&#123;sampleID2&#125;.idr.log</code>三个文件，分别记录了每个peak在两个样本之间的分布与重叠，peaks的可重复性，两个样本之间重复peaks的比例</p>
<p>具体的坐标轴意义与解读方法可以参考<a target="_blank" rel="noopener" href="https://github.com/nboley/idr">官方文档</a>，大概就是上面两幅图的点在y&#x3D;x对角线上越密集表示两个样本之间的重叠率越高，实验的可重复性越好。<br><img src="/./img/ChIP/SRR19318133_SRR19318134.png" alt="idr.png"></p>
<h2 id="04-下游分析与可视化展示"><a href="#04-下游分析与可视化展示" class="headerlink" title="04.下游分析与可视化展示"></a>04.下游分析与可视化展示</h2><p>（可选）根据peaks文件所提供的基因组位置信息，提取对应的序列，使用homer或meme分析目的蛋白的结合motif</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待做</span><br></pre></td></tr></table></figure>

<p>使用Deeptools中的软件分析ChIP-seq捕获的序列在TSS位点，peaks区域及其周边的分布</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将bam文件转化为bw文件</span></span><br><span class="line">samtools index $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;.bam</span><br><span class="line">bamCoverage -b $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;.bam -o $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;_raw.bw </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据参考基因组的注释bed文件，统计捕获序列在各个基因区域的富集情况</span></span><br><span class="line">computeMatrix scale-regions -S $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;_raw.bw  \</span><br><span class="line">                            -R $&#123;genome_gene_bed&#125; \</span><br><span class="line">                            --beforeRegionStartLength 3000 \</span><br><span class="line">                            --regionBodyLength 3000 \</span><br><span class="line">                            --afterRegionStartLength 3000 \</span><br><span class="line">                            --skipZeros -o $&#123;out_path&#125;/$&#123;sampleID&#125;_raw_matrix_gene.mat.gz -p 20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可视化捕获序列在各区域的分布强度</span></span><br><span class="line">plotHeatmap -m $&#123;out_path&#125;/$&#123;sampleID&#125;_raw_matrix_gene.mat.gz \</span><br><span class="line">            -out $&#123;out_path&#125;/$&#123;sampleID&#125;_peaks_heatmap.png --sortUsing sum</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据得到的peaks文件，统计捕获序列在peaks区域的富集情况</span></span><br><span class="line">computeMatrix reference-point -S $&#123;out_path&#125;/sorted_$&#123;sampleID&#125;_raw.bw \</span><br><span class="line">                              -R $&#123;out_path&#125;/$&#123;sampleID&#125;_peaks.narrowPeak \</span><br><span class="line">                              -a 3000 \</span><br><span class="line">                              --referencePoint center \</span><br><span class="line">                              -b  3000 \</span><br><span class="line">                              --skipZeros -o $&#123;out_path&#125;/$&#123;sampleID&#125;_Peak.mat.gz -p 20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可视化捕获序列在各区域的分布强度</span></span><br><span class="line">plotHeatmap -m &#123;out_path&#125;/$&#123;sampleID&#125;_Peak.mat.gz -out &#123;out_path&#125;/$&#123;sampleID&#125;_Peak_heatmap.png --sortUsing sum --startLabel &quot;Peak Start&quot; -\</span><br><span class="line">-endLabel &quot;Peak End&quot; --xAxisLabel &quot;&quot; --regionsLabel &quot;Peaks&quot; --samplesLabel $&#123;sampleID&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/ChIP/raw_heatmap.png" alt="捕获序列在基因区域的覆盖情况"></p>
<h2 id="05-总结"><a href="#05-总结" class="headerlink" title="05. 总结"></a>05. 总结</h2><ul>
<li>数据的预处理过程通过fastp实现，主要包括过滤低质量的reads，切割低质量的片段，去除接头等常规基因组数据预处理流程。</li>
<li>完成比对之后，首先需要提取比对结果中的每个PE的Insert size，来判断数据质量，ChIP-seq捕获的片段长度峰值通常在200-400bp左右</li>
<li>Spike-in数据可以更加准确地去除不同样本间测序深度的差异</li>
<li>应该注意比较样本间的重复性如何，评估实验结果的可靠性与可重复性。</li>
<li>完成了Peak calling之后，可以通过 ①选取top，②差异比对，③共性筛选 等方法缩小Peaks范围（后者需要多个样本间数据相互校正）。</li>
<li>下游分析主要根据Peaks的基因组分布特征（特异分布于promoter区之类的）与Peaks内的序列特征（motif）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/01/transcriptome-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/01/transcriptome-analysis/" class="post-title-link" itemprop="url">transcriptome_analysis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-05-01 21:06:53 / Modified: 22:48:42" itemprop="dateCreated datePublished" datetime="2024-05-01T21:06:53+08:00">2024-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/transcriptome/" itemprop="url" rel="index"><span itemprop="name">transcriptome</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>这篇文章主要用于记录转录组数据分析的流程与要点，尽可能全面准确地描述整个分析过程与每一步的意义。<br>转录组的数据目前通常是通过提取组织mRNA并逆转录为cDNA，再通过二代测序获得的短片段（150bp）的序列。</p>
<p>由于转录过程可能涉及到 <strong>可变剪切</strong> ， <strong>转录本融合</strong> 等一系列转录后修饰事件，通常需要注释文件（gtf,gff）辅助基因组建立索引，可以使用<a target="_blank" rel="noopener" href="https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf">STAR</a> , Hisat2 等软件对转录组索引进行构建；如没有注释文件的话，也可以用Hisat2直接构建转录组索引，但可能比对的效果会差一些。</p>
<p>将原始数据中的每一条reads比对到对应的转录本后，我们就可以根据每条转录本上的reads数量对该转录本的表达水平进行定量。常用的软件有<a target="_blank" rel="noopener" href="https://github.com/deweylab/RSEM">RSEM</a>, StringTie。</p>
<blockquote>
<p>而不同批次间的差异与转录本的长度会影响到reads比对到该转录本上的数量（长转录本在测序过程中被捕获到的数量往往会更多些，测序量更大的实验组，捕获的reads数量也会更多），因此常根据这两项对转录本的定量进行标准化，常见的为FPKM，RPKM, TPM。</p>
</blockquote>
<p>当我们获得了每个样本的转录表达谱后，我们可以对这个高维矩阵进行 <strong>主成分分析</strong> ，鉴定不同实验组之间的差异性。同时可以根据自己的实验设计，对不同组别间某些基因的表达情况进行差异分析，共表达分析等。在本次实验中，我们主要进行了 <strong>差异表达基因分析</strong> 。可以用热图，曼哈顿图等多种方式展示差异表达情况。</p>
<p>筛选出来的基因可以根据需求进行功能富集分析，motif分析等来找到导致其差异表达的因素。</p>
<h1 id="01-Install"><a href="#01-Install" class="headerlink" title="01. Install"></a>01. Install</h1><h2 id="1-1-转录组比对软件STAR"><a href="#1-1-转录组比对软件STAR" class="headerlink" title="1.1 转录组比对软件STAR"></a>1.1 转录组比对软件STAR</h2><p>可以直接克隆<a target="_blank" rel="noopener" href="https://github.com/alexdobin/STAR/">STAR</a>在Github上的工程到本地并开始使用，也可以下载安装包后编译使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接克隆后就可以使用</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/alexdobin/STAR.git</span><br></pre></td></tr></table></figure>

<h2 id="1-2-安装数据质控软件FastQC"><a href="#1-2-安装数据质控软件FastQC" class="headerlink" title="1.2 安装数据质控软件FastQC"></a>1.2 安装数据质控软件FastQC</h2><p>直接在<a target="_blank" rel="noopener" href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/">官网</a>上下载压缩包，解压后就可以使用FastQC。是我个人过滤高通量数据常用的软件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.12.1.zip</span><br><span class="line">unzip fastqc_v0.12.1.zip</span><br></pre></td></tr></table></figure>

<h2 id="1-3-安装转录本定量软件RSEM"><a href="#1-3-安装转录本定量软件RSEM" class="headerlink" title="1.3 安装转录本定量软件RSEM"></a>1.3 安装转录本定量软件RSEM</h2><p>RSEM还需要一些基础的安装环境，不知道为什么我的Unbuntu上居然没有，大家用自己的服务器可以直接make，不许要前面的apt install</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Unbuntu中确实相应的库，一般不用跑这两步</span></span><br><span class="line">sudo apt install build-essential   </span><br><span class="line">sudo apt install zlib1g-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常规的安装步骤</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/deweylab/RSEM.git</span><br><span class="line">make &amp; make install DESTDIR=/home/gujianhui/bio_tools/RSEM  prefix=/RSEM</span><br></pre></td></tr></table></figure>

<h1 id="02-Preparation"><a href="#02-Preparation" class="headerlink" title="02.Preparation"></a>02.Preparation</h1><h2 id="2-1-建立转录组索引"><a href="#2-1-建立转录组索引" class="headerlink" title="2.1 建立转录组索引"></a>2.1 建立转录组索引</h2><p>可以从数据库中下载相应的基因组数据与基因组注释文件（转录组比对比较推荐gtf文件），也可以直接下载STAR官方提供的一些转录组索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若数据库只提供gff文件，可以使用gffread将gff文件转化为gtf文件格式</span></span><br><span class="line">gffread -T gff_file -o gtf_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># STAR建立比对索引(使用gtf建立索引)</span></span><br><span class="line"><span class="variable">$&#123;path_to_STAR&#125;</span>/STAR \</span><br><span class="line">--runThreadN 20 \</span><br><span class="line">--runMode genomeGenerate \</span><br><span class="line">--genomeDir ./   \</span><br><span class="line">--genomeFastaFiles <span class="variable">$&#123;path_to_genome&#125;</span>/TAIR10.fa  \</span><br><span class="line">--sjdbGTFfile <span class="variable">$&#123;path_to_gtf&#125;</span>/TAIR10.gtf \</span><br><span class="line">--sjdbOverhang 149</span><br><span class="line"></span><br><span class="line"><span class="comment"># or STAR建立比对索引(使用gff建立索引)</span></span><br><span class="line"><span class="variable">$&#123;path_to_STAR&#125;</span>/STAR \</span><br><span class="line">--runThreadN 20 \</span><br><span class="line">--runMode genomeGenerate \</span><br><span class="line">--genomeDir ./   \</span><br><span class="line">--genomeFastaFiles <span class="variable">$&#123;path_to_genome&#125;</span>/TAIR10.fa  \</span><br><span class="line">--sjdbGTFtagExonParentTranscript Parent  \</span><br><span class="line">--sjdbGTFfile <span class="variable">$&#123;path_to_gff&#125;</span>/TAIR10.gff \</span><br><span class="line">--sjdbOverhang 149</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体每个参数的意义可以参考 <a target="_blank" rel="noopener" href="https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf">STAR手册</a>或者我之前的文章。<code>--clip3pNbases</code> 参数可以跳过测序质量较差的开头几个碱基，提高比对效率，但会在bam文件中造成软跳过，无法用后续的RSEM进行定量</p>
<p>除此之外，使用RSEM进行转录本的定量也需要建立对应的索引。<a target="_blank" rel="noopener" href="https://open.bioqueue.org/home/knowledge/showKnowledge/sig/rsem-prepare-reference">rsem-prepare-reference</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rsem-prepare-reference --gtf <span class="variable">$&#123;path_to_gtf&#125;</span>/TAIR10.gtf \</span><br><span class="line">-p 10  \</span><br><span class="line"><span class="variable">$&#123;path_to_genome&#125;</span>/TAIR10.fa  \</span><br><span class="line">rsem_idx/rsem</span><br></pre></td></tr></table></figure>
<p>在使用过程中发现，rsem-prepare-reference也可以同时建立star，bowtie2等其他常见比对软件的比对索引。建议直接 <code>rsem-prepare-reference -h</code> 查看。</p>
<h2 id="2-2-测序数据过滤"><a href="#2-2-测序数据过滤" class="headerlink" title="2.2 测序数据过滤"></a>2.2 测序数据过滤</h2><p>使用FastQC，fastp对原始测序数据进行评估与过滤，去除其中测序质量较差或存在接头污染的reads pair。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;path_to_fastqc&#125;</span>/fastqc -t 20  \</span><br><span class="line">-o <span class="variable">$&#123;output_dir&#125;</span>  \</span><br><span class="line">*/*.fq.gz</span><br></pre></td></tr></table></figure>
<p>根据质控html报告对测序结果进行裁减过滤等操作，目前的质量一般都还比较OK</p>
<h1 id="03-Map-Quantification"><a href="#03-Map-Quantification" class="headerlink" title="03. Map &amp; Quantification"></a>03. Map &amp; Quantification</h1><p>将处理好的reads文件比对到建立好转录组索引，获取比对结果的toTranscriptome.bam文件（需要设置<code>--quantMode TranscriptomeSAM</code> ）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;path_to_star&#125;</span>/STAR  \</span><br><span class="line">--runMode alignReads \</span><br><span class="line">--runThreadN 12 \</span><br><span class="line">--readFilesIn <span class="variable">$&#123;path_to_data&#125;</span>/*.fq.gz \</span><br><span class="line">--genomeDir <span class="variable">$&#123;STAR_index&#125;</span>  \</span><br><span class="line">--outSAMtype BAM SortedByCoordinate  \</span><br><span class="line">--twopassMode Basic \</span><br><span class="line">--readFilesCommand zcat  \</span><br><span class="line">--quantMode TranscriptomeSAM GeneCounts \</span><br><span class="line">--outFileNamePrefix  <span class="variable">$&#123;prefix&#125;</span>  \</span><br><span class="line">--outTmpDir  <span class="variable">$&#123;output_dir&#125;</span>  \</span><br></pre></td></tr></table></figure>
<p>对于所有reads的比对统计结果存储于 ${prefix}Log.final.out 文件中，包括了比对效率，Unique比对率等等。</p>
<p>若对STAR软件的结果文件比较熟悉的话，可以直接根据 ReadsPerGene.out.tab 文件进行分析，手动写脚本对转录本进行定量，可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1936443">STAR GeneCounts结果定量</a>。也可以用现有的轮子RSEM对比对结果进行定量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rsem-calculate-expression --paired-end  \</span><br><span class="line">--no-bam-output --alignments -p 15 -q 02 \</span><br><span class="line"><span class="variable">$&#123;path_toTranscriptome_bam&#125;</span> \</span><br><span class="line"><span class="variable">$&#123;path_to_rsem_index&#125;</span> \</span><br><span class="line"><span class="variable">$&#123;output_dir&#125;</span></span><br></pre></td></tr></table></figure>
<p>通常，结果文件中的 genes.results就统计了每个基因&#x2F;转录本上的比对reads数量</p>
<h1 id="04-downstream-analysis"><a href="#04-downstream-analysis" class="headerlink" title="04.downstream_analysis"></a>04.downstream_analysis</h1><p>通常进行的转录组分析为差异表达（Differential Expression）分析，我们需要将之前得到的定量数据导入到分析软件&#x2F;环境中。在本次分析中，我主要在R环境中，使用DESeq对转录组结果进行分析。<br>首先，将所有结果文件整合为各实验组的转录表达矩阵。列名为每个实验组的标签，一行对应了一个基因在各个样本中的表达情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsem-generate-data-matrix *.genes.results &gt; merged.genes_result</span><br></pre></td></tr></table></figure>

<p>以下为简单的R分析脚本</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>DESeq2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggrepel<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">exp_df <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&#x27;merged.genes_result&#x27;</span> <span class="punctuation">,</span> </span><br><span class="line">                     header <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> </span><br><span class="line">                     row.names <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调整每个单元格中的数据为整数</span></span><br><span class="line">exp_df <span class="operator">&lt;-</span><span class="built_in">round</span><span class="punctuation">(</span>exp_df<span class="punctuation">,</span>digits <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">exp_mat <span class="operator">&lt;-</span> as.matrix<span class="punctuation">(</span> exp_df<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对实验组数据进行分组</span></span><br><span class="line">groups <span class="operator">&lt;-</span> factor<span class="punctuation">(</span> <span class="built_in">c</span><span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;H&quot;</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span> <span class="punctuation">,</span></span><br><span class="line">                     <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;S0&quot;</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span> <span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;S1&quot;</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span> <span class="punctuation">,</span></span><br><span class="line">                     <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;T0&quot;</span> <span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span> <span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;T1&quot;</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span> <span class="punctuation">)</span> <span class="punctuation">)</span></span><br><span class="line">col_group <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span> row.names <span class="operator">=</span> colnames<span class="punctuation">(</span>exp_df<span class="punctuation">)</span> <span class="punctuation">,</span> </span><br><span class="line">                         groups<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成DESeq对象，并将转录组结果与分组要求输入</span></span><br><span class="line">de_result <span class="operator">&lt;-</span> DESeqDataSetFromMatrix<span class="punctuation">(</span>countData<span class="operator">=</span>exp_mat<span class="punctuation">,</span></span><br><span class="line">                              colData<span class="operator">=</span>col_group<span class="punctuation">,</span></span><br><span class="line">                              design<span class="operator">=</span><span class="operator">~</span>groups<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化数据等</span></span><br><span class="line">de_result <span class="operator">&lt;-</span> DESeq<span class="punctuation">(</span>de_result<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对转录表达谱进行主成分分析，观察不同实验组之间的转录谱差异是否显著</span></span><br><span class="line">plotPCA<span class="punctuation">(</span> rlog<span class="punctuation">(</span>de_result<span class="punctuation">)</span> <span class="punctuation">,</span> intgroup<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;groups&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较指定两组之间的差异表达基因</span></span><br><span class="line">S0_S1_res <span class="operator">&lt;-</span> results<span class="punctuation">(</span> de_result <span class="punctuation">,</span></span><br><span class="line">                      contrast <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;groups&quot;</span><span class="punctuation">,</span><span class="string">&#x27;S0&#x27;</span><span class="punctuation">,</span><span class="string">&quot;S1&quot;</span><span class="punctuation">)</span> <span class="punctuation">,</span></span><br><span class="line">                      alpha<span class="operator">=</span><span class="number">0.05</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span> TO_H_res <span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记在分析过程中存在显著差异（上调，下调等）的基因</span></span><br><span class="line">S0_S1_res<span class="operator">$</span>sig <span class="operator">&lt;-</span> <span class="string">&#x27;no_sig&#x27;</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>row.names<span class="punctuation">(</span>S0_S1_res<span class="punctuation">)</span> <span class="punctuation">)</span> <span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="punctuation">(</span> <span class="built_in">is.na</span><span class="punctuation">(</span>S0_S1_res<span class="operator">$</span>padj<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">==</span><span class="literal">FALSE</span> <span class="operator">&amp;</span> S0_S1_res<span class="operator">$</span>padj<span class="punctuation">[</span>i<span class="punctuation">]</span> <span class="operator">&lt;</span> <span class="number">0.05</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="punctuation">(</span> S0_S1_res<span class="operator">$</span>log2FoldChange<span class="punctuation">[</span>i<span class="punctuation">]</span> <span class="operator">&gt;</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      S0_S1_res<span class="operator">$</span>sig<span class="punctuation">[</span>i<span class="punctuation">]</span> <span class="operator">=</span> <span class="string">&#x27;up&#x27;</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="keyword">else</span> <span class="keyword">if</span><span class="punctuation">(</span> S0_S1_res<span class="operator">$</span>log2FoldChange<span class="punctuation">[</span>i<span class="punctuation">]</span> <span class="operator">&lt;</span> <span class="operator">-</span><span class="number">1</span> <span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      S0_S1_res<span class="operator">$</span>sig<span class="punctuation">[</span>i<span class="punctuation">]</span> <span class="operator">=</span> <span class="string">&#x27;down&#x27;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据注释结果与差异分析结果绘制火山图，展示两组实验之间发生表达变化的基因</span></span><br><span class="line">ggplot<span class="punctuation">(</span>data<span class="operator">=</span>S0_S1_res<span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>log2FoldChange<span class="punctuation">,</span> y <span class="operator">=</span><span class="operator">-</span>log10<span class="punctuation">(</span>padj<span class="punctuation">)</span><span class="punctuation">,</span>color <span class="operator">=</span>sig<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  ylim<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  scale_color_manual<span class="punctuation">(</span>values <span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;no_sig&#x27;</span><span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">                               <span class="string">&#x27;up&#x27;</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span></span><br><span class="line">                               <span class="string">&#x27;down&#x27;</span> <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_hline<span class="punctuation">(</span>yintercept <span class="operator">=</span> log10<span class="punctuation">(</span><span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">0.6</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.8</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_vline<span class="punctuation">(</span>xintercept <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">0.6</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.8</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme_bw<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>panel.border <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        panel.grid.major <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        panel.grid.minor <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.line <span class="operator">=</span> element_line<span class="punctuation">(</span>colour <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title<span class="operator">=</span><span class="string">&quot;Volcanoplot_biotrainee S0 vs S1&quot;</span><span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;log2 (fold change)&quot;</span><span class="punctuation">,</span>y<span class="operator">=</span><span class="string">&quot;-log10 (padj)&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  </span><br><span class="line">  theme<span class="punctuation">(</span>plot.title <span class="operator">=</span> element_text<span class="punctuation">(</span>hjust <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_text_repel<span class="punctuation">(</span>data<span class="operator">=</span>subset<span class="punctuation">(</span>S0_S1_res<span class="punctuation">,</span> <span class="operator">-</span>log10<span class="punctuation">(</span>padj<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">6</span><span class="punctuation">)</span><span class="punctuation">,</span> aes<span class="punctuation">(</span>label<span class="operator">=</span>Gene<span class="punctuation">)</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span>alpha <span class="operator">=</span><span class="number">0.8</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/14/genome_assembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/14/genome_assembly/" class="post-title-link" itemprop="url">genome assembly</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-03-14 14:27:59 / Modified: 16:35:28" itemprop="dateCreated datePublished" datetime="2024-03-14T14:27:59+08:00">2024-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/genome/" itemprop="url" rel="index"><span itemprop="name">genome</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>这份报告主要用以记录在用长片段测序结果组装基因组的方案，流程以及遇到的一些困难与分析结果。</p>
<p>长片段测序的HIFI数据，常用<a target="_blank" rel="noopener" href="https://github.com/chhylp123/hifiasm">hifiasm</a>这一软件进行初步组装，完成Contig水平的基因组。 再补充HIC数据后，可以juicer+3D-DNA, yahs等软件对Contig再次进行组装，成为scaffold水平的基因组。在对软件拼接结果的手动调整后，可能可以得到染色体水平的基因组文件。</p>
<p>tips: contig和scaffold的概念主要是在使用 <strong>二代测序</strong> 获得短片段组装基因组的时候提出的，这两者在HIC挂载后的长度差异较大。<br>但是用了 <strong>三代测序</strong> 的长片段后，这两者的长度差异小了许多,这两个概念相对模糊了一点</p>
<h1 id="1-Install-software"><a href="#1-Install-software" class="headerlink" title="1. Install software"></a>1. Install software</h1><p>在实际操作过程中，主要采用了hifiasm+juicer+3D-DNA的组装策略</p>
<h2 id="1-1-安装hifiasm"><a href="#1-1-安装hifiasm" class="headerlink" title="1.1 安装hifiasm"></a>1.1 安装hifiasm</h2><h3 id="1-1-1-conda安装"><a href="#1-1-1-conda安装" class="headerlink" title="1.1.1 conda安装"></a>1.1.1 conda安装</h3><p><code>conda install -c bioconda hifiasm </code></p>
<h3 id="1-1-2-github安装"><a href="#1-1-2-github安装" class="headerlink" title="1.1.2 github安装"></a>1.1.2 github安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/chhylp123/hifiasm</span><br><span class="line">$ <span class="built_in">cd</span> hifiasm &amp;&amp; make </span><br></pre></td></tr></table></figure>


<h2 id="1-2-安装AGB-（将gfa转为fa文件-可选）"><a href="#1-2-安装AGB-（将gfa转为fa文件-可选）" class="headerlink" title="1.2 安装AGB （将gfa转为fa文件,可选）"></a>1.2 安装AGB （将gfa转为fa文件,可选）</h2><p>hifiasm输出的文件为gfa组装文件，要将其转化为fasta文件便于后续分析，可以使用AGB。也可以自己写脚本去转一下格式。 笔者这边偷懒就用AGB了<br><code>conda create -c almiheenko -c bioconda -n AGB agb</code></p>
<h2 id="1-3-juicer安装"><a href="#1-3-juicer安装" class="headerlink" title="1.3 juicer安装"></a>1.3 juicer安装</h2><p>juicer相比于其他的HIC数据比对软件运行起来需要准备的文件更多一些，但一个命令行就可以把原始数据过滤，比对等一系列过程全部完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/aidenlab/juicer.git</span><br><span class="line">$ <span class="built_in">cd</span> juicer</span><br><span class="line">$ <span class="built_in">ln</span> -s juicer/CPU scripts</span><br><span class="line">$ <span class="built_in">cd</span> scripts/common</span><br></pre></td></tr></table></figure>

<p>以上步骤都和网络上的教程差不多，但部分教程会推荐安装juicer_tools 1.9版本(适配于Juicer1.6)，这可能会因为版本(git clone 下载的版本为juicer 2.0)不匹配，无法正常输出 <strong>inter.txt</strong> 文件，故需要安装juicer_tools 2.0及以上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c https://github.com/aidenlab/Juicebox/releases/download/v2.20.00/juicer_tools.2.20.00.jar</span><br><span class="line">$ <span class="built_in">ln</span> -s juicer_tools.2.20.00.jar juicer_tools.jar</span><br></pre></td></tr></table></figure>
<p>参考<a target="_blank" rel="noopener" href="https://phantom-aria.github.io/2023/07/11/a.html">Hi-C染色体挂载（1）——juicer2处理Hi-C数据</a></p>
<blockquote>
<p>Github官方文档说明 <a target="_blank" rel="noopener" href="https://github.com/aidenlab/juicer">juicer</a><br>The beta release for Juicer version 1.6 can be accessed via the Github Release. The main repository on Github is now focused on the Juicer 2.0 release and is under active development. For general questions, please use the Google Group.</p>
</blockquote>
<h2 id="1-4-3D-DNA安装"><a href="#1-4-3D-DNA安装" class="headerlink" title="1.4 3D-DNA安装"></a>1.4 3D-DNA安装</h2><p>直接git clone就行 <a target="_blank" rel="noopener" href="https://github.com/aidenlab/3d-dna">3D-DNA</a><br><code>$ git clone https://github.com/theaidenlab/3d-dna.git</code></p>
<h1 id="2-基因组组装"><a href="#2-基因组组装" class="headerlink" title="2. 基因组组装"></a>2. 基因组组装</h1><p>所需文件： </p>
<ol>
<li>HIFI测序文件(fa.gz)</li>
<li>HIC测序文件（_1&#x2F;2.fq.gz）</li>
</ol>
<p>bash变量命名说明：</p>
<ul>
<li>${sp}   物种名称</li>
<li>${hic_sample}  hic测序文件前缀编号</li>
<li>${path_to_hic} hic文件所在路径</li>
<li>${path_to_hifi} hifi文件所在路径</li>
<li>${hifi_sample}   hifi测序文件前缀编号</li>
</ul>
<h2 id="2-1-hifiasm拼接"><a href="#2-1-hifiasm拼接" class="headerlink" title="2.1 hifiasm拼接"></a>2.1 hifiasm拼接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ conda activate hifiasm</span><br><span class="line">$ hifiasm  --primary -o <span class="variable">$&#123;sp&#125;</span>_hifiasm \</span><br><span class="line">-t 20 \</span><br><span class="line">--h1 <span class="variable">$&#123;path_to_hic&#125;</span>/<span class="variable">$&#123;sp&#125;</span>_HIC_R1.fq.gz  \</span><br><span class="line">--h2 <span class="variable">$&#123;path_to_hic&#125;</span>/<span class="variable">$&#123;sp&#125;</span>_HIC_R2.fq.gz  \ </span><br><span class="line"><span class="variable">$&#123;path_to_hifi&#125;</span>/<span class="variable">$&#123;hifi_sample&#125;</span>.fa.gz &gt; assembly_log</span><br></pre></td></tr></table></figure>
<p>具体可以参考<a target="_blank" rel="noopener" href="https://hifiasm.readthedocs.io/en/latest/index.html">hifiasm文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--primary  输出主要的组装结果</span><br><span class="line">-o 输出文件前缀</span><br><span class="line">-t threads数量，运行该命令的线程数</span><br><span class="line">--h1 HIC文件的read1文件</span><br><span class="line">--h2 HIC文件的read2文件</span><br></pre></td></tr></table></figure>
<p>最后得到的许多文件中，主要使用了p_ctg.gfa文件</p>
<ul>
<li>可选分析<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计每个contig的长度，进而计算N50, L50</span></span><br><span class="line">grep <span class="string">&#x27;^S&#x27;</span> <span class="variable">$&#123;sp&#125;</span>_hifiasm.hic.p_ctg.gfa |awk <span class="string">&#x27;&#123;print $2 , length($3)&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将gfa文件转化为fasta文件</span></span><br><span class="line">$ agb.py --graph <span class="variable">$&#123;sp&#125;</span>_hifiasm.p_ctg.gfa -a hifiasm</span><br><span class="line">$ <span class="built_in">mv</span> agb_output/<span class="variable">$&#123;sp&#125;</span>_hifiasm.p_ctg.fasta   <span class="variable">$&#123;sp&#125;</span>.hifi.fasta</span><br></pre></td></tr></table></figure>


<h2 id="2-2-juicer比对"><a href="#2-2-juicer比对" class="headerlink" title="2.2 juicer比对"></a>2.2 juicer比对</h2><p>在使用juicer对HIC数据进行比对前，需要准备一系列的文件：①酶切位点位置文件; ②基因组lens文件 ; ③基因组bwa索引 ; ④包含了HIC测序文件的fastq文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成基因组酶切位点位置文件</span></span><br><span class="line">Python <span class="variable">$&#123;path_to_juicer&#125;</span>/misc/generate_site_positions.py  DpnII  <span class="variable">$&#123;sp&#125;</span>  <span class="variable">$&#123;sp&#125;</span>.hifi.fasta</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成基因组lens文件 , $&#123;sp&#125;_DpnII为上一步的结果文件，也可以用samtools faidx生成lens文件</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;print $1, $NF&#125;&#x27;</span> <span class="variable">$&#123;sp&#125;</span>_DpnII.txt &gt; <span class="variable">$&#123;sp&#125;</span>.lens</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立基因组bwa索引</span></span><br><span class="line">bwa index <span class="variable">$&#123;sp&#125;</span>.hifi.fasta</span><br></pre></td></tr></table></figure>

<p>上述三个内容都可以在同一文件夹下，随后在该文件夹下创建 <strong>fastq</strong> 文件夹，并将HIC数据放在 <strong>fastq</strong> 文件夹中，然后就可以运行juicer了。<br>！！！ <strong>fastq</strong> 文件中的文件必须以 <strong>fastq.gz</strong> 结尾，否则无法识别。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bash <span class="variable">$&#123;path_to_juicer&#125;</span>/scripts/juicer.sh \</span><br><span class="line">-d ./</span><br><span class="line">-g <span class="variable">$&#123;sp&#125;</span> \</span><br><span class="line">-D <span class="variable">$&#123;path_to_juicer&#125;</span> \</span><br><span class="line">-z <span class="variable">$&#123;sp&#125;</span>.hifi.fasta \</span><br><span class="line">-y <span class="variable">$&#123;sp&#125;</span>_DpnII.txt \</span><br><span class="line">-p <span class="variable">$&#123;sp&#125;</span>.lens \</span><br><span class="line">-s DpnII \</span><br><span class="line">-t 20 \</span><br><span class="line">--assembly</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-d top-level路径，在该路径下应该包含fastq文件夹，且输出文件aligned和splits也会在该路径下</span><br><span class="line">-g 基因组的名字，这个可以随便取</span><br><span class="line">-D juicer软件路径，在该路径下要包含 scripts文件夹</span><br><span class="line">-z bwa索引的前缀</span><br><span class="line">-y 基因组酶切位点文件的路径</span><br><span class="line">-p 基因组长度文件的路径</span><br><span class="line">-s 用于做HIC的酶切酶名称</span><br><span class="line">-t threads，运行该命令的线程数</span><br><span class="line">--assembly 用以输出3D-DNA所需的 merged_nodups文件（juicer1.6不需要加这个）</span><br></pre></td></tr></table></figure>

<p>在 <strong>inter.txt</strong> 文件中可以看到HIC文件的比对率以及重复率等统计结果，用以评判数据质量是否符合要求，数据是否需要多测</p>
<h2 id="2-3-3D-DNA挂载"><a href="#2-3-3D-DNA挂载" class="headerlink" title="2.3 3D-DNA挂载"></a>2.3 3D-DNA挂载</h2><p>3D-DNA的输入文件比较简单，只需要输入参考基因组（hifi拼接出来的contig文件）以及juicer比对结果文件（merged_nodups.txt）即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash <span class="variable">$&#123;path_to_3D-DNA&#125;</span>/run-asm-pipeline.sh \</span><br><span class="line">-r 2 \</span><br><span class="line"><span class="variable">$&#123;sp&#125;</span>.hifi.fasta \</span><br><span class="line">merged_nodups.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r 校正连接的迭代次数</span><br></pre></td></tr></table></figure>

<p>最终3D-DNA输出的hic文件可以用juicerbox打开，并手动矫正，可以参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xD4y1m712/?vd_source=96abe912d50da25b76af5c20d7a0979e">juicerbox教程</a>,也可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012110870/article/details/115511969">徐洲更老师的博客</a></p>
<h1 id="3-数据评估"><a href="#3-数据评估" class="headerlink" title="3. 数据评估"></a>3. 数据评估</h1><p>根据上述过程中的组装和比对结果，可以对拼接得到的基因组有一个大概的了解：染色体条数，基因组大小等。<br>在我个人组装的过程中存在以下问题：</p>
<ol>
<li>HIC比对率低(30%-40%)，PCR重复率高(60%-70%)，而在师姐之前的实验记录中，她的测序深度大约为我的10倍，比对率在70%左右，PCR重复&lt;20%。</li>
<li>3D-DNA挂载结果不佳，染色体间与染色体内的互作强度相近，软件几乎无法区分出染色体。</li>
</ol>
<p>为排除可能的因素，首先测试了比对软件，选用了 <strong>chromap+yahs</strong> 的方法去进行比对挂载，发现问题仍然存在。因此，有可能是数据文件的质量不佳，且初步怀疑是 <strong>HIC文库复杂度低</strong> 导致的。</p>
<p>考虑到目前已经获取了对应物种的转录组数据，因此计划使用 转录组与hifi组装结果进行比对 ，确保hifi数据不存在问题。</p>
<p>而常用的转录组比对软件STAR需要基因组注释文件，组装的contig基因组尚未进行基因组注释。故选用hisat2对转录组和hifiasm结果文件进行比对测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立hisat2比对索引</span></span><br><span class="line">$ hisat2-build -p 10 \  <span class="comment">#线程数</span></span><br><span class="line"><span class="variable">$&#123;sp&#125;</span>.hifi.fasta  \  <span class="comment">#hifiasm比对结果文件</span></span><br><span class="line"><span class="variable">$&#123;sp&#125;</span>_hisat_idx   <span class="comment">#输出索引的前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hisat2比对</span></span><br><span class="line">hisat2 -x <span class="variable">$&#123;sp&#125;</span>_hisat_idx \   <span class="comment">#基因组索引</span></span><br><span class="line">-1 <span class="variable">$&#123;path_to_hic&#125;</span>/<span class="variable">$&#123;sp&#125;</span>_HIC_R1.fq.gz \  <span class="comment">#HIC_reads1</span></span><br><span class="line">-2 <span class="variable">$&#123;path_to_hic&#125;</span>/<span class="variable">$&#123;sp&#125;</span>_HIC_R2.fq.gz  \   <span class="comment">#HIC_reads2</span></span><br><span class="line">-S <span class="variable">$&#123;sp&#125;</span>_hisat.sam \   <span class="comment">#输出结果文件</span></span><br><span class="line">-p 10   <span class="comment">#线程数</span></span><br></pre></td></tr></table></figure>

<p>hisat2的比对结果展示了 &gt;90% 的转录组reads 能够比对上hifiasm的组装结果文件，可以交叉验证这两组数据来自于同一物种且具有较高的质量，这证明了： <strong>HIFI数据质量可靠，HIC数据可能存在较大的质量问题</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/03/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/03/test/" class="post-title-link" itemprop="url">trim the reads with special apdater and barocde</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-03-03 15:33:41" itemprop="dateCreated datePublished" datetime="2024-03-03T15:33:41+08:00">2024-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-03-14 14:36:32" itemprop="dateModified" datetime="2024-03-14T14:36:32+08:00">2024-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/single-cell/" itemprop="url" rel="index"><span itemprop="name">single-cell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="read结构"><a href="#read结构" class="headerlink" title="read结构"></a>read结构</h1><p>R1 5’→3’: genome_sequence<br>R2 5’→3’: special_adapter + barcode1 + linker1 + barcode2 + linker2 + barcode3 + genome_sequence</p>
<p>Rawdata文件中的read1和read2序列通常去除了P5和P7接头。<br>而在本次我处理的read文件中，read2的5’端加上了一段特定的额外接头序列(seq1)，而在这一段接头序列之后又连接了单细胞特异的barcode结构： barcode1 + linker1 + barcode2 + linker2 + barcode3。</p>
<h2 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h2><ol>
<li>过滤read pair, 只提取read2 5’端具有 seq1 的 read pair。这一部分的工作可以由cutadapt完成。</li>
<li>过滤 第1步中处理好的 reads 文件，筛选其中 5’端 具有特定barcode结构的read pair，并获取read ID 和 barcode 之间的对应关系。这一部分的工作应该可以用UMItools完成，但我这次打算先自己写脚本处理。</li>
<li>过滤低质量，短长度的reads。这一部分的工作可以用fastp完成。</li>
</ol>
<h2 id="预期得到的文件"><a href="#预期得到的文件" class="headerlink" title="预期得到的文件"></a>预期得到的文件</h2><ol>
<li>经过trim和高质量的 有效read的R1和R2文件</li>
<li>Reads ID与 barcode 对应的文件</li>
</ol>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><h3 id="cutadapt去除特定的接头序列"><a href="#cutadapt去除特定的接头序列" class="headerlink" title="cutadapt去除特定的接头序列"></a>cutadapt去除特定的接头序列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sample_ID=XXX</span><br><span class="line">$ adapter=XXXXXXXXXXX</span><br><span class="line"></span><br><span class="line">$ cutadapt -G <span class="variable">$&#123;adapter&#125;</span> -j 10 -e 0.1 -O 5 -m 50 \ </span><br><span class="line">--pair-filter=both  --discard-untrimmed -o <span class="variable">$&#123;sample_ID&#125;</span>_cutadapt_R1.fq.gz \ </span><br><span class="line">-p <span class="variable">$&#123;sample_ID&#125;</span>_cutadapt_R2.fq.gz <span class="variable">$&#123;sample_ID&#125;</span>_R1.fq.gz  <span class="variable">$&#123;sample_ID&#125;</span>_R2.fq.gz</span><br></pre></td></tr></table></figure>
<p>cutadapt命令解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-G #指定R2中5&#x27;端的接头序列， 相似的参数还有-g,-a,-A</span><br><span class="line">-j #运行该程序的核数</span><br><span class="line">-e #接头序列与reads序列匹配过程中允许的最大错配率(error rate)</span><br><span class="line">-O #接头序列与reads序列匹配过程中允许的最小重叠长度(overlap)</span><br><span class="line">-m #trim接头之后，如果reads的长度小于该值，则将该条reads丢弃(min-length)</span><br><span class="line">--pair-filter=both #如果read1或read2中的某条序列被丢弃了，那么它对应的read2或read1也同时被丢弃</span><br><span class="line">--discard-untrimmed #将没有被trim的reads丢弃，在本命令中的意思即：若reads2 5&#x27;端无配对得上$&#123;adapter&#125;得序列，则将该reads2丢弃，又因为 --pair-filter=both， 对应的read1也被丢弃</span><br><span class="line">-o, -p #输出裁剪后的对应的R1和R2文件</span><br><span class="line">最后两个就是输入文件</span><br></pre></td></tr></table></figure>


<p>cutdapt的使用可以参考<a target="_blank" rel="noopener" href="https://cutadapt.readthedocs.io/en/stable/guide.html">cutadapt官方文档</a>或者<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4ee2f4d2292f">cutdapt使用详解</a></p>
<h3 id="鉴定具有barcode结构的reads-pair"><a href="#鉴定具有barcode结构的reads-pair" class="headerlink" title="鉴定具有barcode结构的reads pair"></a>鉴定具有barcode结构的reads pair</h3><ol>
<li><p>定义READ类用以存储fastq数据，因为每一个READ ID都对应两条READ，所以这个类中存储的序列信息都是配对存在的。具体的脚本可以参考[identify_barcode.py]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">READ</span>:</span><br><span class="line">    <span class="comment">#define the READ object to store the information of paired reads</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self , ID:<span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.<span class="built_in">id</span> = ID</span><br><span class="line">        self.seq = [ <span class="string">&#x27;&#x27;</span> , <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">        self.anno = [ <span class="string">&#x27;&#x27;</span> , <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">        self.quality = [ <span class="string">&#x27;&#x27;</span> , <span class="string">&#x27;&#x27;</span> ]</span><br><span class="line">        self.barcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self.valid = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
<li><p>从fastq文件中读取对应ID的read1与read2的序列与其他信息。gzip.open相对比较慢，用了据说比较快的pyfastx读取fq.gz文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_paired_fq_file</span>(<span class="params"> r1_file:<span class="built_in">str</span> , r2_file:<span class="built_in">str</span> , limit:<span class="built_in">int</span> = math.inf</span>):</span><br><span class="line">    reads_dic = &#123;&#125;</span><br><span class="line">    file_cnt = <span class="number">0</span>     <span class="comment">#mark which file is loading, read1 or read2 </span></span><br><span class="line">    <span class="keyword">for</span>  tmp_file <span class="keyword">in</span> [ r1_file , r2_file ]:</span><br><span class="line">        read_cnt = <span class="number">0</span></span><br><span class="line">        file_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> read <span class="keyword">in</span> pyfastx.Fastq( tmp_file ):</span><br><span class="line">            tmp_id = read.name[:-<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> reads_dic.get( tmp_id):</span><br><span class="line">                reads_dic[ tmp_id ].add_read( seq =read.seq, anno= <span class="string">&#x27;+&#x27;</span> ,  quality = read.qual , kind = file_cnt )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                reads_dic[ tmp_id ] = READ( tmp_id )</span><br><span class="line">                reads_dic[ tmp_id].add_read( seq =read.seq, anno= <span class="string">&#x27;+&#x27;</span> ,  quality = read.qual , kind = file_cnt )</span><br><span class="line">            read_cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> read_cnt &gt; limit:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> reads_dic</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义判断序列间是否匹配的函数，并根据barcode结构，编写拆分序列的脚本，并一一匹配，判断reads是否有效与对应的barcode编码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#允许错配的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mispair_match</span>(<span class="params"> ref_s:<span class="built_in">str</span> , query_s:<span class="built_in">str</span> , limit:<span class="built_in">int</span> = <span class="number">1</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    mis = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="built_in">len</span>(ref_s) ):</span><br><span class="line">        <span class="keyword">if</span> ref_s[i] == query_s[i]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mis += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> mis &lt;= limit</span><br></pre></td></tr></table></figure></li>
<li><p>输出所有符合要求的reads分别到R1和R2文件中。上述所有脚本都可在[]找到</p>
</li>
</ol>
<p>最后的命令行调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python identify_barcode.py -1 <span class="variable">$&#123;sample_ID&#125;</span>_cutadapt_R1.fq.gz  -2 <span class="variable">$&#123;sample_ID&#125;</span>_cutadapt_R2.fq.gz \</span><br><span class="line">-b 0127_barcode_pool  \</span><br><span class="line">-l TGGT,GAGA  \</span><br><span class="line">-o1 01.data/<span class="variable">$&#123;sample_ID&#125;</span>_filtered_R1   -o2 01.data/<span class="variable">$&#123;sample_ID&#125;</span>_filtered_R2 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1,-2 #输入的R1和R2的fq文件</span><br><span class="line">-b #barcode库文件，不同位置的barcode库用##分割</span><br><span class="line">-l #linker序列，中间用,隔开</span><br><span class="line">-o1,-o2 #输出的R1和R2文件前缀</span><br></pre></td></tr></table></figure>

<h2 id="Fastp过滤reads"><a href="#Fastp过滤reads" class="headerlink" title="Fastp过滤reads"></a>Fastp过滤reads</h2><p>主要就是去除一些裁剪后比较短的序列和低质量的reads。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fastp \</span><br><span class="line">--in1 <span class="variable">$&#123;sampleID&#125;</span>_R1.fq.gz \</span><br><span class="line">--in2 <span class="variable">$&#123;sampleID&#125;</span>_R2.fq.gz \</span><br><span class="line">--out1 <span class="variable">$&#123;sampleID&#125;</span>_clean_R1.fq.gz \</span><br><span class="line">--out2 <span class="variable">$&#123;sampleID&#125;</span>_clean_R2.fq.gz \</span><br><span class="line">--json <span class="variable">$&#123;sampleID&#125;</span>.json \</span><br><span class="line">--html <span class="variable">$&#123;sampleID&#125;</span>.html \</span><br><span class="line">--trim_poly_g --poly_g_min_len 10 \</span><br><span class="line">--trim_poly_x --poly_x_min_len 10 \</span><br><span class="line">--cut_front --cut_tail --cut_window_size 4 \</span><br><span class="line">--qualified_quality_phred 30 \</span><br><span class="line">--low_complexity_filter \</span><br><span class="line">--complexity_threshold 30 \</span><br><span class="line">--length_required 30 \</span><br><span class="line">--thread 4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--in1, --in2, --out1, --out2 #输入与输出文件</span><br><span class="line">--json, --html  #过滤报告输出文件</span><br><span class="line">--trim_poly_g, --trim_poly_x    # trim read两端的poly G/X</span><br><span class="line">--poly_g_min_len, --poly_x_min_len   #定义poly G/X的最短长度</span><br><span class="line"></span><br><span class="line">--cut_front, --cut_tail     #从5&#x27;端 和 3&#x27;端裁剪低质量或低复杂度的窗口</span><br><span class="line">--cut_window_size    # 定义窗口大小</span><br><span class="line">--qualified_quality_phred  #定义窗口内的低质量碱基的阈值</span><br><span class="line">--low_complexity_filter   #对于低复杂度的窗口进行过滤</span><br><span class="line">--complexity_threshold   #定义低复杂度的阈值</span><br><span class="line"></span><br><span class="line">--length_required    #定义裁剪后序列的最短长度，若是小于该值，则舍弃该序列</span><br><span class="line"></span><br><span class="line">--thread   #定义运行该程序的核数量</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/03/home_page/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/03/home_page/" class="post-title-link" itemprop="url">Flying_doggy's home page</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-03-03 15:22:21 / Modified: 16:01:07" itemprop="dateCreated datePublished" datetime="2024-03-03T15:22:21+08:00">2024-03-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to the home page of <strong>flying-doggy</strong>.<br>I am going to write down the report of daily <strong>bioinformatics</strong> work and some thoughts about everything.<br>This website would push me to insist on recording and I hope those work will be helpful to those who found it.</p>
<p>By the way, if you have any question about my reports ,please leave message on my Github account or you can contact me with email: <a href="mailto:&#103;&#x75;&#106;&#105;&#x61;&#110;&#x68;&#x75;&#x69;&#x40;&#103;&#x65;&#110;&#x65;&#99;&#116;&#x69;&#115;&#x2e;&#97;&#99;&#46;&#99;&#110;">&#103;&#x75;&#106;&#105;&#x61;&#110;&#x68;&#x75;&#x69;&#x40;&#103;&#x65;&#110;&#x65;&#99;&#116;&#x69;&#115;&#x2e;&#97;&#99;&#46;&#99;&#110;</a>  .</p>
<h1 id="MAPPING-ANALYSIS"><a href="#MAPPING-ANALYSIS" class="headerlink" title="MAPPING ANALYSIS"></a>MAPPING ANALYSIS</h1><h2 id="pre-processing-reads"><a href="#pre-processing-reads" class="headerlink" title="pre - processing reads"></a>pre - processing reads</h2><p>the application of fastp, Trimmomatic, cutadapt and some self-made script to deal with special structure of designed reads.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h2 id="mapping-to-genome"><a href="#mapping-to-genome" class="headerlink" title="mapping to genome"></a>mapping to genome</h2><p>when the reads are trimmed and filtered, they can be mapped to the genome or assemblied.<br>this part will show the applications of 1. transcriptome-mapping: STAR etc ; 2. genome-mapping: BWA-MEM2 etc ; 3. Methylation-mapping: BISMARK etc ; 4. single-cell-mapping: cellranger </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h2 id="downstream-analysis"><a href="#downstream-analysis" class="headerlink" title="downstream analysis"></a>downstream analysis</h2><p>mapped result are expected to be analysed to discover something we want.<br>we can use tools like Deeptools, bedtools, samtools etc to analyse the result. and it’s also important to make some scripts to complete interesting anlysis.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h1 id="GENOME-ANALYSIS"><a href="#GENOME-ANALYSIS" class="headerlink" title="GENOME ANALYSIS"></a>GENOME ANALYSIS</h1><p>phylogeny, insertion, deletion ,structral variation etc.<br>##</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
